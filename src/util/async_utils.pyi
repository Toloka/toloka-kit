__all__ = [
    'AsyncInterfaceWrapper',
    'AsyncMultithreadWrapper',
    'ComplexException',
    'ensure_async',
    'get_task_traceback',
    'Cooldown',
    'AsyncGenAdapter',
    'generate_async_methods_from',
    'isasyncgenadapterfunction',
]
import asyncio
import asyncio.events
import typing


class ComplexException(Exception):
    """Exception to aggregate multiple exceptions occured.
    Unnderlying exceptions are stored in the `exceptions` attribute.

    Attributes:
        exceptions: List of underlying exceptions.
    """

    def __attrs_post_init__(self) -> None: ...

    def __init__(self, exceptions: typing.List[Exception]) -> None:
        """Method generated by attrs for class ComplexException.
        """
        ...

    exceptions: typing.List[Exception]


def ensure_async(func: typing.Callable) -> typing.Callable[..., typing.Awaitable]:
    """Ensure given callable is async.

    Note, that it doesn't provide concurrency by itself!
    It just allow to treat sync and async callables in the same way.

    Args:
        func: Any callable: synchronous or asynchronous.
    Returns:
        Wrapper that return awaitable object at call.
    """
    ...


T = typing.TypeVar('T')

class AsyncInterfaceWrapper(typing.Generic[T]):
    """Wrap arbitrary object to be able to await any of it's methods even if it's sync.

    Note, that it doesn't provide concurrency by itself!
    It just allow to treat sync and async callables in the same way.
    """

    def __init__(self, wrapped: T): ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, state: bytes) -> None: ...

    def __getattr__(self, name: str): ...


class AsyncMultithreadWrapper(typing.Generic[T]):
    """Wrap arbitrary object to run each of it's methods in a separate thread.

    Examples:
        Simple usage example.

        >>> class SyncClassExample:
        >>>     def sync_method(self, sec):
        >>>         time.sleep(sec)  # Definitely not async.
        >>>         return sec
        >>>
        >>> obj = AsyncMultithreadWrapper(SyncClassExample())
        >>> await asyncio.gather(*[obj.sync_method(1) for _ in range(10)])
        ...
    """

    def __init__(
        self,
        wrapped: T,
        pool_size: int = 10,
        loop: typing.Optional[asyncio.events.AbstractEventLoop] = None
    ): ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, state: bytes) -> None: ...

    def __getattr__(self, name: str): ...


def get_task_traceback(task: asyncio.Task) -> typing.Optional[str]:
    """Get traceback for given task as string.
    Return traceback as string if exists. Or None if there was no error.
    """
    ...


class Cooldown:
    """Ð¡ontext manager that implements a delay between calls occurring inside the context

    Args:
        cooldown_time(int): seconds between calls

    Example:
        >>> coldown = toloka.util.Cooldown(5)
        >>> while True:
        >>>     async with coldown:
        >>>         await do_it()  # will be called no more than once every 5 seconds
        ...
    """

    def __init__(self, cooldown_time): ...

    async def __aenter__(self): ...

    async def __aexit__(self, *exc): ...

    _touch_time: float
    _cooldown_time: int


def generate_async_methods_from(cls):
    """Class decorator that generates asynchronous versions of methods using the provided class.

    This class assumes that every method of the resulting class is either an async gen or async function. In case of
    the naming collision (decorated class already has the method that would have been created by the decorator)
    the new method is not generated. This allows you to custom implement asynchronous versions of non-trivial methods
    while automatically generating boilerplate code.
    """
    ...


YieldType = typing.TypeVar('YieldType')

SendType = typing.TypeVar('SendType')

class SyncGenWrapper:
    def __init__(self, gen: typing.AsyncGenerator[YieldType, SendType]): ...

    def __iter__(self): ...


class AsyncGenAdapter(typing.Generic[YieldType, SendType], typing.AsyncIterable, typing.Awaitable):
    """Adapter class that enables alternative syntax for iteration over async generator.

    This class is used for backwards compatibility. Please use "async for" syntax in new code.

    Examples:
        main syntax
         >>> async for value in AsyncGenAdapter(async_gen): ...
         ...

         alternative syntax (please do not use in new code):
         >>> for value in await AsyncGenAdapter(async_gen): ...
         ...
    """

    def __init__(self, gen: typing.AsyncGenerator[YieldType, SendType]): ...

    async def as_sync_gen(self): ...

    def __await__(self) -> typing.Generator[SyncGenWrapper, None, None]: ...

    def __aiter__(self): ...

    def __getattr__(self, item): ...


def isasyncgenadapterfunction(obj): ...
